---
title: "Armour change analysis"
author: "Thomas Guillerme"
date: "`r Sys.Date()`"
output:
  html_document:
    fig_width: 12
    fig_height: 6
---

```{r}
library(phytools)
library(dispRity)
library(Inapp) # home package
library(landmarktest) # home package
source("../Functions/clade.change_fun.R")
source("../Functions/utilities.R")
set.seed(42)

## Loading the extant data
load("../Data/Processed/extant.rda")
```

Here we want to test:

  1. Whether there is a difference in body size between armoured/non-armoured fishes
  2. Whether there is a difference in body size at the time armour appears/disappear in a phylogeny
  3. Whether the there is a relation between the body size or armoured fishes and the predator's size

If all three are true, we can suggest that armour evolved in fishes as a response to predation.

# Is a difference in body size between armoured/non-armoured fishes?

This is a crude analysis simply to test if there is a difference between the fishes with and without armour.
A simple t-test can be used here.

```{r}
## The tree
tree <- spine_data$tree

## The body size values
body_size_values <- spine_data$spine_data[, 3]

## Armour values
armour_values <- spine_data$armour[,1]

## Selecting both groups
armour_body_sizes <- spine_data$spine_data[which(spine_data$armour[,1] == 1), 3]
nonarm_body_sizes <- spine_data$spine_data[which(spine_data$armour[,1] == 0), 3]

## Logging the data
armour_body_sizes <- log(armour_body_sizes)
nonarm_body_sizes <- log(nonarm_body_sizes)

## Testing the differences
armour_bs_test <- t.test(armour_body_sizes, nonarm_body_sizes)

## Plotting this
boxplot(list("Spines" = armour_body_sizes, "No spines" = nonarm_body_sizes),
        ylab = "Log(body size)")
text(1, -0.25, paste0("Mean difference = ",
  round(abs(armour_bs_test$estimate[1]-armour_bs_test$estimate[2]), digits = 3),
  "\np = ", round(armour_bs_test$p.value, digits = 3)))
```

Nice.
Something is happening.

## Correlation between body length and armourness

We can also measure the correlation between body length and armourness more precisely using the Threshold model (`phytools::threshBayes`).

```{r, fig.height = 6, fig.width = 6}
## Creating the matrix of traits
trait_matrix <- cbind(spine_data$armour[, 1], body_size_values)

## Threshold model
#mcm_binary_1M <- threshBayes(tree, trait_matrix, types = c("discrete","continuous"), ngen = 1000000)
#save(mcm_binary_1M, file = "../Data/Processed/MCMC_living_binary_1M.rda")
load("../Data/Processed/MCMC_living_binary_1M.rda")

## The MCMC results
mcm_binary_1M
plot(mcm_binary_1M)
```

Excellent: there is a negative correlation between body length and armourness: the smaller you get, the more likely you are to evolve have spines!

This is how the the phylogeny and the reconstructed states look:


```{r, fig.height = 10, fig.width = 10}
## get the node changes
results_topol <- run.timespines(body_size_values, armour_values, tree,
                                method = "topol",
                                taxa.names = rownames(spine_data$spine_data))

## Create a vector of two colours
spine_cols <- c("white", "black")

## Calculating the traits ancestral values
traits <- body_size_values[match(tree$tip.label, rownames(spine_data$spine_data))]
names(traits) <- tree$tip.label
trait_map <- contMap(tree, traits, plot = FALSE)

## Results plot
par(mar = c(1,1,1,1))
plot(trait_map, fsize = 0.001, type = "fan", lwd = 2)

## Adding the spine colours
tiplabels(pch = 21, cex = 0.7, col = "black")
tiplabels(pch = 16, cex = 0.7,
          col = spine_cols[armour_values[match(tree$tip.label, rownames(spine_data$spine_data))]+1])

## Adding the node changes
nodelabels(pch = 21, node = unlist(results_topol$node.changes), cex = 1.5, lwd = 3,
           col = c("lightgrey", "darkgrey")[results_topol$node.origin+1],
           bg = c("black", "white")[results_topol$node.origin+1])

## Legends
legend("topleft",legend = c("Not spiny", "Spiny", "Loss of spines", "Gain of spines"), pch = 21,
       col = c("black", "black", "darkgrey", "lightgrey"), pt.bg = spine_cols, bty = "n",
       lwd = c(rep(1,2), rep(3,2)), lty = 0, cex = 0.9, pt.cex = c(1, 1, 1.5, 1.5))

legend("bottomleft",legend = paste(round(trait_map$lims, digit = 2), collapse = " Body length "),
       bty = "n")

```

There.
The hypotheses are then, first:

 1. Does gain of spine correspond to a decrease in body length? Alternatively, does the loss of spine correspond to an increase in body size? (entering/exiting the Danger Zone)

And second:

 2. Is the body size at the time of the gain/loss of spines linked to the relative?


# Is a difference in body size at the time armour appears/disappear in a phylogeny

So now lets see whether the changes in armourness occurs when there is a change in body size.
The hypothesis being that:

 1. Is there a relation between change in armourness regime (i.e. presence or absence) and body length within clades.
 In other words, are taxa with/without armour bigger/smaller than the rest.

 2. If 1 is true, is there a relation between members in a clade having armour and the size of the top predator.

To check these hypothesis, we use two approaches based on topology only or on topology and branch length.
Both approach are based on the same principles:

  1. Estimating the armour origination state of a clade (i.e. the state of armourness at the appearance of the clade)
  2. Measure the body length of taxa in the clade that do not have the origination state.

For the second hypothesis, we can then make these body lengths relative to the biggest predator's length.

The topology and topology+branch length method only differ in the way to measure the armourness origination state:

 1. When based on topology only, the origination state is the state that is represented in majority in the clade (parsimony-like --- if there is no strict majority, the origination state is arbitrarily set to no-armour (0))
 2. When based on topology and branch length, the origination state is estimated using a likelihood ancestral state estimation calculation based on the taxa' states and branch length
 + The length at the node is used.

See analysis 02 for discussion on the pros and cons of both methods.

```{r, fig.width = 6, fig.height = 6}
## Running the results for topology
results_topol <- run.timespines(body_size_values, armour_values, tree,
                                method = "topol",
                                taxa.names = rownames(spine_data$spine_data))

## Running the results for topology and branch length
results_brlen <- run.timespines(body_size_values, armour_values, tree,
                                method = "brlen",
                                taxa.names = rownames(spine_data$spine_data))
```

We can now visualise where do the group changes occur relative to their group size:

```{r, fig.width = 6, fig.height = 12}
par(mfrow = c(2,1))
## Plotting the pooled data for every group
plot.change(results_topol, main = "Topology", xlab = "Scaled log BL")
## Plotting the pooled data for every group
plot.change(results_brlen, main = "Topology and branch length", xlab = "Scaled log BL")
```

We then need to test whether this difference is significant or not.

## Testing the body size at time of appearance

For that we can use a kind of permutation test (here an exact bootstrap test).
This checks whether a statistic observed in a subset of a distribution (here the median) is different from the same statistic measured in the overall distribution.

If the results are out of the range from the statistics from the overall distribution ($p < 0.05$) then there is a different between the subset distribution (body size at time of appearance) and the rest of the distribution.

The values compared are $median_bs - median_obs$, positive values indicate that the observed data is smaller

```{r}
## Running the test for the topology
topology_gain <- run.bootstraps(results_topol, what = 0)
topology_loss <- run.bootstraps(results_topol, what = 1)

## Running the test for the branch length
brlength_gain <- run.bootstraps(results_brlen, what = 0)
brlength_loss <- run.bootstraps(results_brlen, what = 1)
```

```{r, fig.width = 12, fig.height = 12}
par(mfrow = c(2,2))
## Plotting the results function
bootstrap.test.plot <- function(test_result, main, n_test) {
    ## Plotting the pooled data for every group
    plot(test_result, main = main, xlab = "Median difference")
    add.rare.plot(test_result)
    ## Add the text
    legend(ifelse(test_result$obs < test_result$expvar[2], "topleft", "topright"), bty = "n",
      paste0("p = ", round(p.adjust(test_result$pvalue, "bonferroni", n = n_test), 5), sep = "\n"))
}
bootstrap.test.plot(topology_gain, main = "Topology - gain", n_test = 4)
bootstrap.test.plot(topology_loss, main = "Topology - loss", n_test = 4)
bootstrap.test.plot(brlength_gain, main = "Branch length - gain", n_test = 4)
bootstrap.test.plot(brlength_loss, main = "Branch length - loss", n_test = 4)
```

So there seems to be evidence for evolving armour when entering the Danger Zone (median body mass when gaining armour is always low) but no evidence for loosing armour when leaving the Danger Zone (median body mass when loosing armour is not different).

This could be interpreted as the armour being gained as a response to the predator prey arms race but once the armour is gained, it could serve other function (exaptations) and is subsequently no loosed when leaving the Danger Zone.


# Is there an effect of predator size at the time of gain/loss of armour?

To answer this question, we will need the body length of the fishes at the time of one clade's armour gain/loss and the geographic area.
We can then check whether there is a relation with the body length of the fish gaining/loosing armour and the biggest fish at the time and the geographic area.

## Ancestral body lengths

We can use a simple ancestral nodes estimation for the body lengths following a normal Brownian model of evolution of body length.

```{r}
## Ancestral states estimations for the body lengths
ace_body_lengths <- ace(traits, tree)

## Combining all ancestral states into a data.frame
body_length_data <- data.frame("BodyLength" = c(traits, ace_body_lengths$ace),
                               "CI025" = c(traits, ace_body_lengths$CI95[,1]),
                               "CI975" = c(traits, ace_body_lengths$CI95[,2]))
```

## Ancestral geographic areas

We can do something similar for the geographic area using B




```{r}
# Load the package (after installation, see above).
library(optimx)         # You need to have some version of optimx available
                        # as it is a BioGeoBEARS dependency; however, if you
                        # don't want to use optimx, and use optim() (from R core) 
                        # you can set:
                        # BioGeoBEARS_run_object$use_optimx = FALSE
                        # ...everything should work either way -- NJM 2014-01-08
library(FD)       # for FD::maxent() (make sure this is up-to-date)
library(snow)     # (if you want to use multicore functionality; some systems/R versions prefer library(parallel), try either)
library(parallel)
library(BioGeoBEARS)

########################################################
# TO GET THE OPTIMX/OPTIM FIX, AND THE UPPASS FIX, 
# SOURCE THE REVISED FUNCTIONS WITH THESE COMMANDS
#
# CRUCIAL CRUCIAL CRUCIAL: 
# YOU HAVE TO RUN THE SOURCE COMMANDS AFTER 
# *EVERY TIME* YOU DO library(BioGeoBEARS). THE CHANGES ARE NOT "PERMANENT", 
# THEY HAVE TO BE MADE EACH TIME.  IF YOU ARE GOING TO BE OFFLINE, 
# YOU CAN DOWNLOAD EACH .R FILE TO YOUR HARD DRIVE AND REFER THE source()
# COMMANDS TO THE FULL PATH AND FILENAME OF EACH FILE ON YOUR
# LOCAL SYSTEM INSTEAD.
########################################################
library(BioGeoBEARS)
source("http://phylo.wdfiles.com/local--files/biogeobears/cladoRcpp.R") # (needed now that traits model added; source FIRST!)
source("http://phylo.wdfiles.com/local--files/biogeobears/BioGeoBEARS_add_fossils_randomly_v1.R")
source("http://phylo.wdfiles.com/local--files/biogeobears/BioGeoBEARS_basics_v1.R")
source("http://phylo.wdfiles.com/local--files/biogeobears/BioGeoBEARS_calc_transition_matrices_v1.R")
source("http://phylo.wdfiles.com/local--files/biogeobears/BioGeoBEARS_classes_v1.R")
source("http://phylo.wdfiles.com/local--files/biogeobears/BioGeoBEARS_detection_v1.R")
source("http://phylo.wdfiles.com/local--files/biogeobears/BioGeoBEARS_DNA_cladogenesis_sim_v1.R")
source("http://phylo.wdfiles.com/local--files/biogeobears/BioGeoBEARS_extract_Qmat_COOmat_v1.R")
source("http://phylo.wdfiles.com/local--files/biogeobears/BioGeoBEARS_generics_v1.R")
source("http://phylo.wdfiles.com/local--files/biogeobears/BioGeoBEARS_models_v1.R")
source("http://phylo.wdfiles.com/local--files/biogeobears/BioGeoBEARS_on_multiple_trees_v1.R")
source("http://phylo.wdfiles.com/local--files/biogeobears/BioGeoBEARS_plots_v1.R")
source("http://phylo.wdfiles.com/local--files/biogeobears/BioGeoBEARS_readwrite_v1.R")
source("http://phylo.wdfiles.com/local--files/biogeobears/BioGeoBEARS_simulate_v1.R")
source("http://phylo.wdfiles.com/local--files/biogeobears/BioGeoBEARS_SSEsim_makePlots_v1.R")
source("http://phylo.wdfiles.com/local--files/biogeobears/BioGeoBEARS_SSEsim_v1.R")
source("http://phylo.wdfiles.com/local--files/biogeobears/BioGeoBEARS_stochastic_mapping_v1.R")
source("http://phylo.wdfiles.com/local--files/biogeobears/BioGeoBEARS_stratified_v1.R")
source("http://phylo.wdfiles.com/local--files/biogeobears/BioGeoBEARS_univ_model_v1.R")
source("http://phylo.wdfiles.com/local--files/biogeobears/calc_uppass_probs_v1.R")
source("http://phylo.wdfiles.com/local--files/biogeobears/calc_loglike_sp_v01.R")
source("http://phylo.wdfiles.com/local--files/biogeobears/get_stratified_subbranch_top_downpass_likelihoods_v1.R")
source("http://phylo.wdfiles.com/local--files/biogeobears/runBSM_v1.R")
source("http://phylo.wdfiles.com/local--files/biogeobears/stochastic_map_given_inputs.R")
source("http://phylo.wdfiles.com/local--files/biogeobears/summarize_BSM_tables_v1.R")
source("http://phylo.wdfiles.com/local--files/biogeobears/BioGeoBEARS_traits_v1.R") # added traits model
calc_loglike_sp = compiler::cmpfun(calc_loglike_sp_prebyte)    # crucial to fix bug in uppass calculations
calc_independent_likelihoods_on_each_branch = compiler::cmpfun(calc_independent_likelihoods_on_each_branch_prebyte)
    # slight speedup hopefully


#######################################################


## The tree ("tree" in the tutorial) 
tree <- tree

# This is the example geography file for Hawaiian JuliaDupin
# (from Ree & Smith 2008)
geogfn = np(paste(addslash(extdata_dir), "Psychotria_geog.data", sep=""))

# Look at the raw geography text file:
moref(geogfn)

# Look at your geographic range data:
tipranges = getranges_from_LagrangePHYLIP(lgdata_fn=geogfn)
tipranges

# Set the maximum number of areas any species may occupy; this cannot be larger 
# than the number of areas you set up, but it can be smaller.
max_range_size = 4

#######################################################
# Run DEC
#######################################################

BioGeoBEARS_run_object = define_BioGeoBEARS_run()
BioGeoBEARS_run_object$force_sparse=FALSE    # sparse=FALSE causes pathology & isn't much faster at this scale
BioGeoBEARS_run_object$speedup=TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)
BioGeoBEARS_run_object$use_optimx = TRUE
BioGeoBEARS_run_object$calc_ancprobs=TRUE    # get ancestral states from optim run

# Set up a time-stratified analysis 
# (un-comment to use; see example files in extdata_dir, 
#  and BioGeoBEARS google group posts for further hints)
BioGeoBEARS_run_object$timesfn = np(slashslash(paste(extdata_dir2, "timeperiods.txt", sep="/")))
BioGeoBEARS_run_object$dispersal_multipliers_fn = np(slashslash(paste(extdata_dir2, "dispersal_multipliers.txt", sep="/")))
BioGeoBEARS_run_object$areas_allowed_fn = np(slashslash(paste(extdata_dir2, "areas_allowed.txt", sep="/")))
#BioGeoBEARS_run_object$areas_adjacency_fn = "areas_adjacency.txt"
#BioGeoBEARS_run_object$distsfn = "distances_matrix.txt"
# See notes on the distances model on PhyloWiki's BioGeoBEARS updates page.

# Input the maximum range size
BioGeoBEARS_run_object$max_range_size = max_range_size

# Multicore processing if desired
BioGeoBEARS_run_object$num_cores_to_use=1
# (use more cores to speed it up; this requires
# library(parallel) and/or library(snow). The package "parallel" 
# is now default on Macs in R 3.0+, but apparently still 
# has to be typed on some Windows machines. Note: apparently 
# parallel works on Mac command-line R, but not R.app.
# BioGeoBEARS checks for this and resets to 1
# core with R.app)

# Sparse matrix exponentiation is an option for huge numbers of ranges/states (600+)
# I have experimented with sparse matrix exponentiation in EXPOKIT/rexpokit,
# but the results are imprecise and so I haven't explored it further.
# In a Bayesian analysis, it might work OK, but the ML point estimates are
# not identical.
# Also, I have not implemented all functions to work with force_sparse=TRUE.
# Volunteers are welcome to work on it!!
BioGeoBEARS_run_object$force_sparse=FALSE

# Give BioGeoBEARS the location of the geography text file
BioGeoBEARS_run_object$geogfn = geogfn

# Give BioGeoBEARS the location of the phylogeny Newick file
BioGeoBEARS_run_object$tree = tree

# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!
# (It also runs some checks on these inputs for certain errors.)
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)

# Divide the tree up by timeperiods/strata (uncomment this for stratified analysis)
BioGeoBEARS_run_object = section_the_tree(inputs=BioGeoBEARS_run_object, make_master_table=TRUE, plot_pieces=FALSE)
# The stratified tree is described in this table:
#BioGeoBEARS_run_object$master_table

# Good default settings to get ancestral states
BioGeoBEARS_run_object$return_condlikes_table = TRUE
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE
BioGeoBEARS_run_object$calc_ancprobs = TRUE

# Set up DEC+J model

# Add j as a free parameter
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","type"] = "free"
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","init"] = 0.001
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","est"] = 0.001

# Look at the BioGeoBEARS_run_object; it's just a list of settings etc.
BioGeoBEARS_run_object

# This contains the model object
BioGeoBEARS_run_object$BioGeoBEARS_model_object

# This table contains the parameters of the model 
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table

# Run this to check inputs. Read the error messages if you get them!
check_BioGeoBEARS_run(BioGeoBEARS_run_object)

# For a slow analysis, run once, then set runslow=FALSE to just 
# load the saved result.
runslow = TRUE
resfn = "Psychotria_DEC+J_M3b_strat_v1.Rdata"
if (runslow)
    {
    res = bears_optim_run(BioGeoBEARS_run_object)
    res    

    save(res, file=resfn)
    } else {
    # Loads to "res"
    load(resfn)
    }

###########################################
# Pick your model name:
###########################################
model_name = "DEC+J_M3b_strat"
# res = resDEC

#######################################################
# Plot ancestral states - DEC
#######################################################
pdffn = paste0("Psychotria_", model_name, "_v1.pdf")
pdf(pdffn, width=6, height=6)

analysis_titletxt = paste0(model_name, " on Psychotria")

# Setup
results_object = res
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))

# States
res2 = plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="text", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)

# Pie chart
plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="pie", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)

dev.off()  # Turn off PDF
cmdstr = paste("open ", pdffn, sep="")
system(cmdstr) # Plot it

```

<!-- Here we can perform exactly the same test but by scaling the results -->

```{r, eval = FALSE, echo = FALSE}
## Scaling the distributions
sca_distribution_topol <- distribution_topol/max(distribution_topol)
sca_distribution_brlen <- distribution_brlen/max(distribution_brlen)

## Applying the random tests
sca_test_topol <- bootstrap.test(sca_distribution_topol, subset_topol, statistic = median,
                                 replicates = 500, rarefaction = TRUE)

## Applying the random test for the branch length
sca_test_brlen <- bootstrap.test(sca_distribution_brlen, subset_brlen, statistic = median,
                                 replicates = 500, rarefaction = TRUE)
```

```{r, eval = FALSE, echo = FALSE}
par(mfrow = c(2,1))
## Plotting the pooled data for every group
plot(sca_test_topol, main = "Topology (scaled)", xlab = "Median difference")
add.rare.plot(sca_test_topol)
## Add the text
legend(ifelse(sca_test_topol$obs < sca_test_topol$expvar[2], "topleft", "topright"),
  paste0("p = ", round(sca_test_topol$pvalue, 5), sep = "\n")  , bty = "n")


## Plotting the pooled data for every group
plot(sca_test_brlen, main = "Branch length (scaled)", xlab = "Median difference")
add.rare.plot(sca_test_brlen)
## Add the text
legend(ifelse(sca_test_brlen$obs < sca_test_brlen$expvar[2], "topleft", "topright"),
  paste0("p = ", round(sca_test_brlen$pvalue, 5), sep = "\n")  , bty = "n")
```

<!-- Unsurprisingly the results are not different. -->

<!-- > Need to improve this test. Not sure if it's savy. -->

<!-- > Need to correct the p-values. -->